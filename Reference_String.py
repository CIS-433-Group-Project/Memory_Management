from random import randint, choice, random
from enum import Enum
from time import time


class Behavior(Enum):
    RANDOM = 1
    WELLBEHAVED = 2
    TERRIBLE = 3
    AVERAGE = 4
    LOOP = 5


def generate_list(behavior: Behavior, loop_len=None):
    """
    Generates the list which represents the program being simulated.  The length of execution is fixed at 10,000 page
    requests, as is the size of the program on disk at 99 pages.  No guarantee that all pages on disk will be requested.
    No two consecutive elements in the list will be equivalent.  No other guarantees of repetition are made beyond those
    governed by the rules of the behaviors as specified below.  (E.g.:  the 90/10 rule behavior does not guarantee any
    minimum value for requests for any of the elements in the 90% "working set," only that roughly 9,000 of the page
    requests generated by that program can be mapped to a set of, at most, 10 pages.)
    :param behavior: a Behavior instance; specifies behavior of the program this string simulates.
    :param loop_len: optional argument.  Specifies length of loop, if loop behavior is specified.
    :return: a list of integers representing the page requests of a program as it executes.
    """
    LENGTH = 10**4
    RANGE = 99
    ref = []
    # Random program behavior.  Only guarantees that ref[i] != ref[i+1].
    if behavior == Behavior.RANDOM:
        app = ref.append
        l = range(RANGE+1)
        last = None
        for _ in range(LENGTH):
            c = choice(l)
            while c == last:
                c = choice(l)
            last = c
            app(c)
    # Implementation of average program behavior.  Assumes average programs simply adhere to the 90-10 rule.
    elif behavior == Behavior.AVERAGE:
        ref = []
        append = ref.append
        ws = range(RANGE+1)
        working_set = []
        while len(working_set) < 10:
            working_set = {choice(ws) for _ in range(len(ws)//10)}
        working_set = list(working_set)
        leftovers = [i for i in ws if i not in working_set]
        append(choice(leftovers))
        last = ref[0]
        c = last
        for _ in range(1, LENGTH):
            placement = random()
            # Pulls from the "common" 10% if the random value above was <= 0.9; pulls from the "leftovers" otherwise.
            # Guarantees the 90/10 rule for reasonably uniform random distributions.
            if placement > 0.9:
                while c == last:
                    c = choice(leftovers)
            else:
                while c == last:
                    c = choice(working_set)
            append(c)
            last = c
        # this is just checking to make sure we've gotten roughly 90% usage of our "common" pages.  The dict tallying
        # method here is slightly inefficient, but it preserves how commonly each page was used, which was useful during
        # testing.
        uses = {i: sum([1 if i == j else 0 for j in ref]) for i in working_set}
        ninety = len(ref)*9/10
        ten = len(ref)/10
        assert ninety - ten < sum(i for i in uses.values()) < len(ref)
        return ref
    # Implementation of Loop behavior.
    else:
        ref = [None]*LENGTH
        pages = [i for i in range(RANGE+1)]
        if loop_len is None:
            loop_len = randint(3, 12)
        start = randint(0, RANGE)
        # construct the loop
        loop = []
        for i in range(loop_len):
            loop.append(pages[(start + i) % len(pages)])
        loop_iterations = int(LENGTH*randint(7, 9)/10/len(loop))
        # remove the pages in our loop from the set we'll use to construct the rest of the reference string
        for i in loop:
            pages.remove(i)
        # decide on a starting position for the loop
        loop_start = randint(0, LENGTH - len(loop)*loop_iterations - 1)
        # put the loop in place for however many iterations it will run.  Note that for the purposes of this
        # this constructor, the reference string is double-ended - the loop is allowed to "begin" at the end and "end"
        # at the beginning.
        for i in range(len(loop)*loop_iterations):
            ref[loop_start + i] = loop[i % len(loop)]
        if ref[0] is None:
            ref[0] = choice(pages)
        # Populate the rest of the reference string.
        for i in range(1, LENGTH):
            if ref[i] is None:
                last = ref[i-1]
                if last in pages:
                    p = pages.copy()
                    p.remove(last)
                    ref[i] = choice(p)
                else:
                    ref[i] = choice(pages)
        assert set(pages).union(loop) == {i for i in range(RANGE+1)}
        assert loop_iterations*len(loop) + len(pages) <= LENGTH
    assert all(i is not None for i in ref)
    assert all(ref[i] != ref[i+1] for i in range(len(ref)-1))
    return ref


if __name__ == '__main__':
    TRIALS = 10**2
    time_start = time()
    for _ in range(TRIALS):
        n = generate_list(Behavior.AVERAGE)
    time_end = time()
    print('Time elapsed: ', time_end - time_start)
    print('Average time: ', (time_end - time_start)/TRIALS)
    with open('test_string_loop.txt', 'w') as file_out:
        file_out.write(', '.join([str(i) for i in n]))

